# Инструкция по работе с Гит и удаленными репозиториями

## Что такое ГИТ?
Гит - это одна из реализаций распределенныъ систем контроля версий, имеющая как локальные, так и удаленные репозитории. Является самой популярной реальзацией систем контроля версий в мире.

## Подготовка репозитория
Для создания репозитория необходимо выполнить команду *git init* в папке с репозиторием и у Вас появится репозиторий (появится скрытая папка .git)

## Создание коммитов 

### Git add
Для добавления изменений в коммит используется команда *git add*. Чтобы использовать команду *git add* напишите *git add <имя файла>*

### Просмотр состояния репозитория
Для того чтобы просмотреть состояние репозитория используется команда #git status*. Для этого необходимо в папке   репозиторием написать , и Вы увидите были ли изменения в файлах или их не было.

### Создание коммитов
Добавить коммит в Git можно следующим образом. Для этого необходимо выполнить 2 команды. Первая команда git add -A добавляет все измененные файлы в индекс. А вторая команда создает коммит.

git add -A
git commit -m "Commit message."
Если вам нужно создать коммит, но добавлять в него не все измененные файлы, а только определенные, то при использовании команды git add необходимо указать через пробел добавляемые в индекс файлы. Например: git add goodfile.cpp goodfile.h
git commit -m "Commit message."

Коммит — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:

git commit
Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды edit. Сохраняемся, и вуаля! Коммит готов. Есть несколько ключей, упрощающих работу с git commit.

Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено:

git commit -a
Комментирует коммит прямо из командной строки вместо текстового редактора:

git commit -m «commit comment»
Вносит в индекс и создаёт коммит на основе изменений единственного файла:

git commit FILENAME
Пример написания хорошего сообщения коммита:

Описывает изменение (до 50 символов)

Более детальное объяснение, если необходимо. Перенос на 72 символе
или около того. В некоторых контекстах первая строка рассматривается
как тема письма, а остальное как тело. Пустая строка, отделяющая сводку
от тела, важна (если вы не опустили тело целиком); если вы оставите их
вместе, инструменты, такие как rebase, могут воспринять это неправильно.

Дальнейшие параграфы идут после пустых строк

 - также можно применять маркеры списков

 - обычно в качестве маркера списка используется дефис или звёздочка
   с одним пробелом перед ним и пустыми строками между пунктами,
   хотя соглашения в этом аспекте могут разниться

Если вы используете систему отслеживания задач, поставьте ссылки на нее:

Resolves: #123
See also: #456, #789

![Git commands](https://media.dev.to/cdn-cgi/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fi%2Frixan4h4z8y94eq89som.png)

4 Fixes For Git Error: You Need To Resolve Your Current Index First

Git is a powerful version control system that helps developers manage their codebase efficiently. However, like any other tool, it can sometimes encounter errors that need to be resolved. One common error message that Git users may encounter is “You need to resolve your current index first.” This error typically occurs when there are conflicts between the changes in the repository and the changes in the working directory. 

1. Use the Git stash command: The Git stash command allows you to temporarily save your local changes and revert your working directory to the last committed state. To resolve the current index error using Git stash, follow these steps:

Run the command git stash to save your local changes.
After stashing, run git stash drop to remove the saved changes from the stash.
Finally, run git pull to fetch the latest changes from the remote repository.
2. Reset the index to the last commit: If you don’t need your local changes and want to discard them, you can reset the index to the last commit using the following steps:

Run git reset --hard HEAD to reset the index and discard all local changes.
After resetting, run git pull to fetch the latest changes from the remote repository.
3. Resolve conflicts manually: If you want to keep your local changes and manually resolve the conflicts, you can follow these steps:

Use the command git status to identify the files with conflicts.
Open each conflicting file in a text editor and look for the conflict markers (<<<<<<<, =======, and >>>>>>>).
Modify the conflicting lines to resolve the conflicts according to your requirements.
After resolving all conflicts, run git add <file> for each file to mark them as resolved.
Finally, run git commit to create a new commit with the resolved conflicts.
4. Use a merge tool: Git provides several merge tools that can help visualize and resolve conflicts more easily. If you prefer a graphical interface to handle conflicts, you can configure Git to use a merge tool such as KDiff3, P4Merge, or Beyond Compare. To set up a merge tool, follow these steps:

Run git config --global merge.tool <tool-name> to set the desired merge tool.
When conflicts occur, use the command git mergetool to launch the configured tool.
Use the merge tool to manually resolve the conflicts and save the changes.
After resolving all conflicts, run git commit to create a new commit with the resolved conflicts.
## Pictures - Как добавить изображение из файла
Первый способ, как отобразить локальное изображение в markdown документе, это использовать следующий код:

![Текст с описанием картинки](/images/picture.jpg)
Часть в квадратных скобках - это так называемый альтернативный текст, который важен по следующим причинам:

Для доступности. Программы чтения с экрана читают именно его. Например, для тех, кто плохо видит.
Этот текст будет отображаться вместо изображения, если файл изображения не может быть загружен.
Он обеспечивает контекст и описание изображения для поисковых систем, помогая им с поиском.

Часть в круглых скобках - это путь к файлу. Обрати внимание, что перед images стоит /. Без этого символа твой документ может отображаться нормально на твоем компьютере, но после загрузки на сервер в интернете она отображаться перестанет. Это одна из основных причин, почему так случается.

Другой способ, как отобразить локальное изображение в markdown публикации, это использовать тег image в тексте документа:

<image src="/images/picture.jpg" alt="Текст с описанием картинки">
Одним из преимуществ этого способа заключается в том, что так можно использовать дополнительные возможности для контроля изображения. Специфика зависит от ресурса, на котором ты публикуешь документ.
Любой из этих способов даст нужный результат, так что выбор за тобой.
## extra
Работа с локальным репозиторием
Из индекса и дерева проекта одновременно файл можно удалить командой git rm.
Удаляет из индекса и дерева проекта отдельные файлы:

git rm FILE1 FILE2
Хороший пример удаления из документации к git, удаляются сразу все файлы txt из папки:

git rm Documentation/\*.txt
Вносит в индекс все удаленные файлы:

git rm -r --cached .
Сбросить весь индекс или удалить из него изменения определенного файла можно командой git reset:

git reset
Удаляет из индекса конкретный файл:

git reset — EDITEDFILE
Команда git reset используется не только для сбрасывания индекса, поэтому дальше ей будет уделено гораздо больше внимания.
## Commands
*git status* — состояние проекта, измененные и не добавленные файлы, индексированные файлы
Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто: git status
Кроме того, git status указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые git.

## git revert — отмена изменений, произведенных в прошлом отдельным коммитом
Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. git revert создает новый коммит, накладывающий обратные изменения.

Отменяет коммит, помеченный тегом:

git revert config-modify-tag
Отменяет коммит, используя его хэш:

git revert cgsjd2h
Для отмены коммита слияния (коммита у которого несколько родителей), необходимо указать хэш и номер одного из родителей коммита:

git revert cgsjd2h -m 1
Для использования команды необходимо, чтобы состояние проекта не отличалось от состояния, зафиксированного последним коммитом.

## git log — разнообразная информация о коммитах в целом
Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда git log.

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):

git log
Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):

git log -p
Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:

git log --stat
За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:

git log --summary
Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):

git log README
или, если версия git не совсем свежая:

git log — README
Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):

git log --since=«1 day 2 hours» README
git log --since=«2 hours» README
изменения, касающиеся отдельной папки:

git log --since=«2 hours» dir/
Можно отталкиваться от тегов.

Все коммиты, начиная с тега v1:

git log v1...
Все коммиты, включающие изменения файла README, начиная с тега v1:

git log v1... README
Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:

git log v1..v2 README
Интересные возможности по формату вывода команды предоставляет ключ --pretty.

Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):

git log --pretty=oneline
Лаконичная информация о коммитах, приводятся только автор и комментарий:

git log --pretty=short
Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:

git log --pretty=full/fuller
В принципе, формат вывода можно определить самостоятельно:

git log --pretty=format:'FORMAT'
Определение формата можно поискать в разделе по git log из Git Community Book или справке. Красивый ASCII-граф коммитов выводится с использованием ключа --graph.
## Работа с удаленным репозиторием
Удаленный (иногда говорят "внешний") репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.

Имя удаленного репозитория в команде *git remote add* вы можете придумать сами. Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени. Принято называть удаленный репозиторий origin, но строго говоря, никаких ограничений здесь нет.

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку Code на странице репозитория на GitHub.

Иногда возникает необходимость забыть удаленный репозиторий. Для этого существует команда *__git remote remove__*.

Иногда возникает необходимость переименовать удаленный репозиторий. Для этого существует команда *__git remote rename__*. 
Формат: git remote rename <старое имя удаленного репозитория> <новое имя удаленного репозитория>
Что делает*: Меняет имя переданного удаленного репозитория

Еще более частая задача – просмотреть список всех подключенных удаленных репозиториев и получить информацию о каждом из них. Для этого существует команда *__git remote show__*. Выводит список всех подключенных удаленных репозиториев. Если передано имя репозитория, то выводит информацию об этом репозитории.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда *__git clone__*. Клонирует переданный репозиторий на ваш компьютер.
## Получение изменений из удаленного репозитория.
Теперь, когда мы научились подключать удаленный репозиторий к локальному и клонировать его к себе на компьютер, пора узнать, как же получить изменения из удаленного репозитория.

У вас может возникнуть вопрос: зачем получать изменения, если только я загружаю их в свой удаленный репозиторий? Все верно, если вы работаете один, то вряд ли вам пригодится загружать изменения из удаленного репозитория в локальный. Но если вы работаете в команде, вы будете по несколько раз в день обновлять свой репозиторий, загружая в него коммиты, сделанные другими разработчиками из вашей команды.

Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда *__git fetch__*. Получает изменения из переданного удаленного репозитория. Если не было передано ни одного удаленного репозитория, ни ключа --all, команда пытается получить изменения из репозитория с именем origin.
Формат: git fetch [ключи] [имя удаленного репозитория] 
Ключи: --all
Получает изменения из всех подключенных удаленных репозиториев.

## Получение изменений из удаленного репозитория
Связкой git fetch && git merge мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она git pull.

Формат: git pull [ключи] [имя удаленного репозитория]

Ключи:
--ff
--no-ff
--ff-only
Эти ключи определяют стратегию слияния. --ff – включить fast-forward, если это возможно, --no-ff – отключить fast-forward, а --ff-only – остановить pull, если его невозможно сделать в fast-forward.

Что делает: Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. По умолчанию слияние удаленной ветки с локальной происходит именно в fast-forward режиме, так что включать его специально не требуется
## Отправка изменений в удаленный репозиторий. Команда git push
Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. Для этого в Git существует команда git push.

Формат: git push [ключи] [имя удаленного репозитория] [имя ветки]

Ключи:
--all
Пушит все имеющиеся ветки

-f, --force
Перезаписывает удаленную ветку, вне зависимости от ее содержимого. Старайтесь не использовать этот флаг без крайней необходимости.

--force-with-lease
Удаляет все коммиты, которых нет в локальном репозитории. Если коммит, который команда соберется удалять был создан другим пользователем, то выполнение закончится с ошибкой.